<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>LSB Steganography Tool</title>
    <style>
        /*
        * LSB Steganography Tool
        * Copyright (c) 2024 derbydefi
        * Released under the MIT License
        * See the full license text at the bottom of this file.
        */
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            font-family: 'IBM Plex Mono', monospace;
            background: #121212;
            color: #d3d3d3;
            line-height: 1.6;

            background-size: 8px 8px;
            background-repeat: repeat;
        }

        h1 {
            font-size: 2rem;
            margin-top: 20px;
            color: #d3d3d3;
            text-align: center;
            text-shadow: 0px 1px 0px #000;
            border-bottom: 1px solid #d3d3d3;
            padding-bottom: 5px;
            width: 90%;
            max-width: 600px;
        }

        section {
            background-color: #1b1b1b;
            border: 1px solid #333;
            padding: 10px;
            border-radius: 4px;
            width: 90%;
            max-width: 600px;
            margin-bottom: 30px;
        }

        h2 {
            font-size: 1.2rem;
            color: #d3d3d3;
            margin-bottom: 15px;
            border-bottom: 1px dashed #555;
            padding-bottom: 5px;
        }

        label {
            font-size: 0.9rem;
            color: #a3a3a3;
        }

        input,
        textarea,
        button,
        a {
            width: 100%;
            margin: 10px 0;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #555;
            background: #2b2b2b;
            color: #d3d3d3;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
        }

        input:focus,
        textarea:focus {
            border-color: #999;
            outline: none;
        }

        button {
            background: #444;
            color: #d3d3d3;
            font-family: 'IBM Plex Mono', monospace;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #555;
        }

        button:disabled {
            background: #333;
            cursor: not-allowed;
        }

        a {
            text-align: center;
            text-decoration: none;
            background: #444;
            color: #d3d3d3;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            transition: background 0.2s;
        }

        a:hover {
            background: #555;
        }

        #spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1rem;
            color: #d3d3d3;
            display: none;
        }

        #messageBox {
            margin: 20px 0;
            text-align: center;
            padding: 5px;
            border-radius: 4px;
            background: #222;
            border: 1px solid #333;
            opacity: 1;
            transition: opacity 1s ease-in-out;
            display: none;
            /* Hide by default */
        }

        #messageBox.error {
            background: #331111;
            color: #ffaaaa;
        }

        #messageBox.success {
            background: #113311;
            color: #aaffaa;
        }

        /* Fade-out effect */
        #messageBox.fade-out {
            opacity: 0;
        }

        .size-info {
            width: 100%;
            margin: 10px 0;
            border-collapse: collapse;
        }

        .size-info td {
            padding: 5px;
            font-size: 0.9rem;
            color: #d3d3d3;
        }

        .size-info tr:nth-child(even) {
            background-color: #1e1e1e;
        }

        .size-info tr:nth-child(odd) {
            background-color: #2b2b2b;
        }

        .size-info td:first-child {
            text-align: left;
        }

        .size-info td:last-child {
            text-align: right;
        }

        /* Highlight when over limit */
        .size-info tr.over-limit td {
            color: #ff5555;
            /* Bright red text */
            font-weight: bold;
        }


        /* Settings Group Styling */
        .settings-group {
            margin-top: 20px;
        }

        .settings-group label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #d3d3d3;
            cursor: pointer;
        }

        .settings-group input[type="checkbox"] {
            margin-right: 5px;
            accent-color: #444;
            width: 16px;
            height: 16px;
        }

        /* Channel Selection Styling */
        #channelSelection {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        #channelSelection label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #d3d3d3;
            cursor: pointer;
        }

        #channelSelection input[type="checkbox"] {
            margin-right: 5px;
            accent-color: #444;
            /* Modern browsers */
            width: 16px;
            height: 16px;
        }

        /* Bit Depth Input Styling */
        #bitDepth {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #555;
            background: #2b2b2b;
            color: #d3d3d3;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
        }

        #bitDepth:focus {
            border-color: #999;
            outline: none;
        }

        /* Hover Effects */
        #channelSelection label:hover {
            color: #fff;
        }

        .settings-group label:hover {
            color: #fff;
        }

        .capacity-bar {
            width: 100%;
            background-color: #2b2b2b;
            border: 1px solid #555;
            border-radius: 4px;
            margin-bottom: 10px;
            height: 20px;
            overflow: hidden;
        }

        .capacity-fill {
            height: 100%;
            background-color: #4caf50;
            width: 0%;
            transition: width 0.3s;
        }

        /* Image Display Styling */
        .image-display {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin-top: 10px;
        }

        .image-container {
            margin: 5px;
            text-align: center;
        }

        .image-container h3 {
            font-size: 1rem;
            color: #d3d3d3;
            margin-bottom: 5px;
        }

        .image-container canvas {
            border: 1px solid #555;
            max-width: 100%;
            height: auto;
        }



        .image-container label {
            font-size: 0.9rem;
            color: #a3a3a3;
            display: block;
            margin-top: 4px;
        }


        /* Slider Styling */
        #amplificationSlider {
            -webkit-appearance: none;
            /* Remove default styling in Chrome/Safari */
            width: 100%;
            height: 6px;
            background: #2b2b2b;
            border-radius: 3px;
            margin: 10px 0 5px;
            /* Top, right/left, bottom */
            outline: none;
            position: relative;
        }

        /* Webkit Browsers (Chrome, Safari, Opera) */
        #amplificationSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            position: relative;
            /* Ensure thumb is positioned relative to the slider */
            top: -4px;
            /* Adjust to align thumb vertically on the track */
            width: 14px;
            height: 14px;
            background: #d3d3d3;
            border-radius: 50%;
            border: 1px solid #555;
            cursor: pointer;
        }

        /* Firefox */
        #amplificationSlider::-moz-range-thumb {
            position: relative;
            top: -4px;
            width: 14px;
            height: 14px;
            background: #d3d3d3;
            border-radius: 50%;
            border: 1px solid #555;
            cursor: pointer;
        }

        /* IE and Edge */
        #amplificationSlider::-ms-thumb {
            position: relative;
            top: -4px;
            width: 14px;
            height: 14px;
            background: #d3d3d3;
            border-radius: 50%;
            border: 1px solid #555;
            cursor: pointer;
        }

        /* Track Styles */
        #amplificationSlider::-webkit-slider-runnable-track {
            height: 6px;
            background: #2b2b2b;
            border-radius: 3px;
        }

        #amplificationSlider::-moz-range-track {
            height: 6px;
            background: #2b2b2b;
            border-radius: 3px;
        }

        #amplificationSlider::-ms-track {
            height: 6px;
            background: transparent;
            border-color: transparent;
            color: transparent;
        }

        #amplificationSlider::-ms-fill-lower {
            background: #2b2b2b;
            border-radius: 3px;
        }

        #amplificationSlider::-ms-fill-upper {
            background: #2b2b2b;
            border-radius: 3px;
        }

        .canvas-slider-container {
            width: 100%;
            /* Make it responsive */
            max-width: 100%;
            /* Ensure it doesn't exceed parent width */
        }

        .canvas-container canvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        .canvas-slider-container canvas,
        .canvas-slider-container #amplificationSlider {
            width: 100%;
            /* Both elements take full width of the container */
            box-sizing: border-box;
            /* Include padding and border in the element's total width */
        }

        /* Images Section - Collapsed by Default */
        #imagesSection {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }

        /* When the 'show' class is added, expand the section */
        #imagesSection.show {
            max-height: 2000px;
            /* Adjust this value as needed */
        }

        /* Style the Toggle Button */
        #toggleImagesButton {
            background: #444;
            color: #d3d3d3;
            font-family: 'IBM Plex Mono', monospace;
            cursor: pointer;
            transition: background 0.2s;
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #555;
            margin-top: 10px;
        }

        #toggleImagesButton:hover {
            background: #555;
        }

        /* New styles for download-container */
        .download-container {
            text-align: right;
        }

        .download-container a {
            display: inline-block;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5rem;
            }

            input,
            textarea,
            button,
            a {
                font-size: 0.8rem;
            }

            #channelSelection {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<!--
        LSB Steganography Tool
        Copyright (c) 2024 derbydefi
        Released under the MIT License
        See the full license text at the bottom of this file.
        -->

<body>
    <h1>⧉ LSB Steganography Tool</h1>
    <div id="messageBox"></div>
    <section>
        <h2>Read And Decode Data From Encoded Image</h2>
        <label for="uploadImageRead">Upload Image</label>
        <input type="file" id="uploadImageRead" accept="image/*">
        <label for="passwordInputDecode">Password (if required)</label>
        <input type="password" id="passwordInputDecode" placeholder="Enter Password">
        <div class="button-container">
            <button id="decodeButton" disabled>Decode Data</button>
        </div>
        <div class="download-container">
            <a id="downloadDecodedFile" style="display: none;">Download Decoded File</a>
        </div>
        <p id="decodedMessage">Decoded Message: <span></span></p>
    </section>
    <section>
        <h2>Write Image With Encoded Data</h2>
        <label for="uploadImageWrite">Source Image</label>
        <input type="file" id="uploadImageWrite" accept="image/*">
        <input type="password" id="passwordInput" placeholder="Enter Password (Optional)">
        <textarea id="messageInput" placeholder="Enter Message"></textarea>
        <label for="uploadFile">Upload File</label>
        <input type="file" id="uploadFile" accept="*">
        <table class="size-info">
            <tr>
                <td>Message Size:</td>
                <td><span id="messageSize">0</span> bytes</td>
            </tr>
        </table>
        <table class="size-info">
            <tr>
                <td>File Size:</td>
                <td><span id="fileSize">0</span> bytes</td>
            </tr>
        </table>
        <table class="size-info">
            <tr id="totalDataSizeLine">
                <td>Total Data Size:</td>
                <td><span id="totalDataSize">0</span> bytes</td>
            </tr>
        </table>
        <table class="size-info">
            <tr>
                <td>Max Data Size:</td>
                <td id="maxBytes"><span>0</span> bytes</td>
            </tr>
        </table>
        <div class="capacity-bar">
            <div class="capacity-fill" id="capacityFill"></div>
        </div>
        <div class="settings-group">
            <label>Encoding Color Channels:</label>
            <div id="channelSelection">
                <label><input type="checkbox" id="channelRed" checked> Red</label>
                <label><input type="checkbox" id="channelGreen"> Green</label>
                <label><input type="checkbox" id="channelBlue"> Blue</label>
            </div>
            <label for="bitDepth">Bit Depth Per Channel:</label>
            <input type="number" id="bitDepth" value="1" min="1" max="16">
            <label><input type="checkbox" id="fillRandomData"> Fill remaining space with random data</label>
        </div>
        <div class="button-container">
            <button id="encodeButton" disabled>Encode Data</button>
        </div>
        <div class="download-container">
            <a id="downloadLink" style="display: none;">Download Encoded Image</a>
        </div>
        <button id="toggleImagesButton">Show Images</button>
        <div id="imagesSection">
            <div class="image-display">
                <div class="image-container">
                    <h3>Original Image</h3>
                    <div class="canvas-container">
                        <canvas id="originalCanvas"></canvas>
                    </div>
                </div>
                <div class="image-container">
                    <h3>Difference</h3>
                    <div class="canvas-container">
                        <canvas id="differenceCanvas"></canvas>
                        <input type="range" id="amplificationSlider" min="1" max="100" value="16">
                    </div>
                    <label for="amplificationSlider">Amplification Factor: <span
                            id="amplificationValue">16</span></label>
                </div>
                <div class="image-container">
                    <h3>Encoded Image</h3>
                    <div class="canvas-container">
                        <canvas id="encodedCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </section>
    <div id="spinner">Processing...</div>
    <canvas id="canvas" style="display: none;"></canvas>
    <script>
        /*
        * LSB Steganography Tool
        * Copyright (c) 2024 derbydefi
        * Released under the MIT License
        * See the full license text at the bottom of this file.
        */
        const canvas = document.getElementById( 'canvas' );
        const ctx = canvas.getContext( '2d' );
        let maxDataSize = 0;
        let amplificationFactor = 16; // Default value
        let uploadedFileData = null;
        let originalImageData = null;
        let encodedImageData = null;
        const originalCanvas = document.getElementById( 'originalCanvas' );
        const originalCtx = originalCanvas.getContext( '2d' );
        const encodedCanvas = document.getElementById( 'encodedCanvas' );
        const encodedCtx = encodedCanvas.getContext( '2d' );
        const differenceCanvas = document.getElementById( 'differenceCanvas' );
        const differenceCtx = differenceCanvas.getContext( '2d' );

        // UI Elements
        const toggleImagesButton = document.getElementById( 'toggleImagesButton' );
        const imagesSection = document.getElementById( 'imagesSection' );
        const spinner = document.getElementById( 'spinner' );
        const messageBox = document.getElementById( 'messageBox' );
        const decodeButton = document.getElementById( 'decodeButton' );
        const encodeButton = document.getElementById( 'encodeButton' );
        const downloadDecodedFile = document.getElementById( 'downloadDecodedFile' );
        const downloadLink = document.getElementById( 'downloadLink' );
        const amplificationSlider = document.getElementById( 'amplificationSlider' );
        const amplificationValue = document.getElementById( 'amplificationValue' );
        const fillRandomDataCheckbox = document.getElementById( 'fillRandomData' );
        const channelRed = document.getElementById( 'channelRed' );
        const channelGreen = document.getElementById( 'channelGreen' );
        const channelBlue = document.getElementById( 'channelBlue' );
        const bitDepthInput = document.getElementById( 'bitDepth' );
        const messageInput = document.getElementById( 'messageInput' );
        const uploadFileInput = document.getElementById( 'uploadFile' );
        const uploadImageWriteInput = document.getElementById( 'uploadImageWrite' );
        const uploadImageReadInput = document.getElementById( 'uploadImageRead' );
        const decodedMessage = document.getElementById( 'decodedMessage' );
        const messageSizeSpan = document.getElementById( 'messageSize' );
        const fileSizeSpan = document.getElementById( 'fileSize' );
        const totalDataSizeSpan = document.getElementById( 'totalDataSize' );
        const maxBytesSpan = document.querySelector( '#maxBytes span' );
        const capacityFill = document.getElementById( 'capacityFill' );
        const totalDataSizeLine = document.getElementById( 'totalDataSizeLine' );

        toggleImagesButton.textContent = 'Show Images';
        const DEFAULT_PASSWORD = "password"

        function generateRandomBytes ( size )
        {
            const MAX_BYTES = 65536; // Maximum bytes per call
            const bytes = new Uint8Array( size );
            let generated = 0;

            while ( generated < size )
            {
                const chunkSize = Math.min( MAX_BYTES, size - generated );
                const chunk = new Uint8Array( chunkSize );
                crypto.getRandomValues( chunk );
                bytes.set( chunk, generated );
                generated += chunkSize;
            }

            return bytes;
        }

        function encodeText ( text )
        {
            return new TextEncoder().encode( text );
        }

        function decodeText ( data )
        {
            return new TextDecoder().decode( data );
        }

        async function encodeData ( data, message, fileData, password )
        {
            let totalDataBytes = new Uint8Array();
            let hasText = message.length > 0;
            let hasFile = fileData !== null;

            if ( !hasText && !hasFile )
            {
                showMessage( 'No data to encode.' );
                return;
            }

            // Prepare text data
            if ( hasText )
            {
                const messageEncoded = encodeText( message );
                const textLengthBuffer = new ArrayBuffer( 4 );
                new DataView( textLengthBuffer ).setUint32( 0, messageEncoded.length );
                const textBytes = new Uint8Array( [
                    ...new Uint8Array( textLengthBuffer ),
                    ...messageEncoded
                ] );
                totalDataBytes = hasFile
                    ? new Uint8Array( [ ...textBytes ] )
                    : textBytes;
            }

            // Prepare file data
            if ( hasFile )
            {
                const fileInput = uploadFileInput;
                const file = fileInput.files[ 0 ];
                const fileName = file.name;
                const mimeType = file.type;
                const fileNameBytes = encodeText( fileName );
                const mimeTypeBytes = encodeText( mimeType );
                const fileContentBytes = new Uint8Array( fileData );

                const fileBytes = new Uint8Array( [
                    fileNameBytes.length,
                    ...fileNameBytes,
                    mimeTypeBytes.length,
                    ...mimeTypeBytes,
                    ...fileContentBytes
                ] );

                if ( hasText )
                {
                    // Append fileBytes to totalDataBytes
                    const combinedLength = totalDataBytes.length + fileBytes.length;
                    const combinedBytes = new Uint8Array( combinedLength );
                    combinedBytes.set( totalDataBytes, 0 );
                    combinedBytes.set( fileBytes, totalDataBytes.length );
                    totalDataBytes = combinedBytes;
                } else
                {
                    totalDataBytes = fileBytes;
                }
            }

            const pwd = password || DEFAULT_PASSWORD;

            // Always encrypt the combined data
            try
            {
                totalDataBytes = await encryptData( totalDataBytes, pwd );
            } catch ( error )
            {
                showMessage( 'Encryption failed. Please try again.', true );
                return;
            }

            // Get selected channels and bit depth
            const selectedChannels = getSelectedChannels();
            const bitDepth = getBitDepth();

            // Prepare header with new settings
            let header = {
                hasText: hasText,
                hasFile: hasFile,
                encrypted: true,
                dataLength: totalDataBytes.length,
                channels: selectedChannels,
                bitDepth: bitDepth
            };

            let headerString = JSON.stringify( header );
            let headerBytes = encodeText( headerString );
            let headerLength = headerBytes.length;

            // Ensure header length fits in one byte
            if ( headerLength > 255 )
            {
                showMessage( 'Header is too large.', true );
                return;
            }

            // Encode header length and header bytes into LSB of red channel
            let dataIndex = 0;
            for ( let bit = 7; bit >= 0; bit-- )
            {
                let bitValue = ( headerLength >> bit ) & 1;
                data[ dataIndex ] = ( data[ dataIndex ] & ~1 ) | bitValue;
                dataIndex += 4; // Move to next pixel
            }

            for ( let i = 0; i < headerLength; i++ )
            {
                let byte = headerBytes[ i ];
                for ( let bit = 7; bit >= 0; bit-- )
                {
                    let bitValue = ( byte >> bit ) & 1;
                    data[ dataIndex ] = ( data[ dataIndex ] & ~1 ) | bitValue;
                    dataIndex += 4; // Move to next pixel
                }
            }

            // Now dataIndex points to the next pixel after the header
            // We can proceed to encode the data
            const bitsPerPixel = selectedChannels.length * bitDepth;
            let bitPosIndex = 0;

            // Generate channel-bit positions based on selected channels and bit depth
            let channelBitPositions = [];
            for ( let channel of selectedChannels )
            {
                for ( let bit = 0; bit < bitDepth; bit++ )
                {
                    channelBitPositions.push( { channel, bit } );
                }
            }

            // Encode data using selected settings
            for ( let i = 0; i < totalDataBytes.length; i++ )
            {
                let byte = totalDataBytes[ i ];
                for ( let bit = 7; bit >= 0; bit-- )
                {
                    let bitValue = ( byte >> bit ) & 1;

                    let pixelOffset = Math.floor( bitPosIndex / bitsPerPixel );
                    let bitWithinPixel = bitPosIndex % bitsPerPixel;
                    let { channel, bit: channelBit } = channelBitPositions[ bitWithinPixel ];

                    let dataIdx = dataIndex + pixelOffset * 4;
                    let channelIndex = { 'R': 0, 'G': 1, 'B': 2 }[ channel ];
                    let baseIndex = dataIdx + channelIndex;

                    let bitMask = 1 << channelBit;
                    data[ baseIndex ] = ( data[ baseIndex ] & ~bitMask ) | ( bitValue << channelBit );

                    bitPosIndex++;
                }
            }

            // If the fill random data option is enabled, fill the remaining space with random data
            if ( isFillRandomDataEnabled() )
            {
                const totalAvailableBits = ( ( data.length / 4 ) - ( dataIndex / 4 ) ) * bitsPerPixel;
                const totalRequiredBits = totalDataBytes.length * 8;
                const remainingBits = totalAvailableBits - totalRequiredBits;
                const remainingBytes = Math.floor( remainingBits / 8 );

                if ( remainingBytes > 0 )
                {
                    const randomBytes = generateRandomBytes( remainingBytes );
                    for ( let i = 0; i < randomBytes.length; i++ )
                    {
                        let byte = randomBytes[ i ];
                        for ( let bit = 7; bit >= 0; bit-- )
                        {
                            let bitValue = ( byte >> bit ) & 1;

                            let pixelOffset = Math.floor( bitPosIndex / bitsPerPixel );
                            let bitWithinPixel = bitPosIndex % bitsPerPixel;
                            let { channel, bit: channelBit } = channelBitPositions[ bitWithinPixel ];

                            let dataIdx = dataIndex + pixelOffset * 4;
                            let channelIndex = { 'R': 0, 'G': 1, 'B': 2 }[ channel ];
                            let baseIndex = dataIdx + channelIndex;

                            let bitMask = 1 << channelBit;
                            data[ baseIndex ] = ( data[ baseIndex ] & ~bitMask ) | ( bitValue << channelBit );

                            bitPosIndex++;
                        }
                    }
                }
            }
        }

        async function decodeData ( data, password )
        {
            let dataIndex = 0;

            // Read header length from LSB of red channel
            let headerLength = 0;
            for ( let bitIndex = 7; bitIndex >= 0; bitIndex-- )
            {
                let bit = data[ dataIndex ] & 1;
                headerLength |= bit << bitIndex;
                dataIndex += 4;
            }

            // Read header bytes
            let headerBytes = new Uint8Array( headerLength );
            for ( let i = 0; i < headerLength; i++ )
            {
                let byte = 0;
                for ( let bitIndex = 7; bitIndex >= 0; bitIndex-- )
                {
                    let bit = data[ dataIndex ] & 1;
                    byte |= bit << bitIndex;
                    dataIndex += 4;
                }
                headerBytes[ i ] = byte;
            }
            const headerString = decodeText( headerBytes );
            const header = JSON.parse( headerString );

            // Get settings from header
            const selectedChannels = header.channels;
            const bitDepth = header.bitDepth;

            // Generate positions
            let channelBitPositions = [];
            for ( let channel of selectedChannels )
            {
                for ( let bit = 0; bit < bitDepth; bit++ )
                {
                    channelBitPositions.push( { channel, bit } );
                }
            }

            const bitsPerPixel = channelBitPositions.length;
            let bitPosIndex = 0;
            let dataBytes = new Uint8Array( header.dataLength );

            // Decode data using settings
            for ( let i = 0; i < header.dataLength; i++ )
            {
                let byte = 0;
                for ( let bitIndex = 7; bitIndex >= 0; bitIndex-- )
                {
                    let pixelOffset = Math.floor( bitPosIndex / bitsPerPixel );
                    let bitWithinPixel = bitPosIndex % bitsPerPixel;
                    let { channel, bit: channelBit } = channelBitPositions[ bitWithinPixel ];

                    let dataIdx = dataIndex + pixelOffset * 4;
                    let channelIndex = { 'R': 0, 'G': 1, 'B': 2 }[ channel ];
                    let baseIndex = dataIdx + channelIndex;

                    let bitMask = 1 << channelBit;
                    let bit = ( data[ baseIndex ] & bitMask ) >> channelBit;

                    byte |= bit << bitIndex;
                    bitPosIndex++;
                }
                dataBytes[ i ] = byte;
            }
            let binaryData;
            const pwd = password || DEFAULT_PASSWORD;
            try
            {
                binaryData = await decryptData( dataBytes, pwd );
            } catch ( e )
            {
                showMessage( 'Failed to decrypt data. Please check the password or data integrity.' );
                return null;
            }

            let result = {};

            let offset = 0;

            // Extract text message if present
            if ( header.hasText )
            {
                const textLengthBytes = binaryData.slice( offset, offset + 4 );
                const textLength = new DataView( textLengthBytes.buffer ).getUint32( 0 );
                offset += 4;
                const textBytes = binaryData.slice( offset, offset + textLength );
                offset += textLength;
                const message = decodeText( textBytes );
                result.text = message;
            }

            // Extract file if present
            if ( header.hasFile )
            {
                const fileNameLength = binaryData[ offset ];
                offset += 1;
                const fileName = decodeText( binaryData.slice( offset, offset + fileNameLength ) );
                offset += fileNameLength;
                const mimeTypeLength = binaryData[ offset ];
                offset += 1;
                const mimeType = decodeText( binaryData.slice( offset, offset + mimeTypeLength ) );
                offset += mimeTypeLength;
                const fileContent = binaryData.slice( offset );
                result.file = {
                    fileName,
                    mimeType,
                    content: fileContent
                };
            }

            return result;
        }

        async function generateKey ( password, salt )
        {
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encodeText( password ),
                { name: 'PBKDF2' },
                false,
                [ 'deriveKey' ]
            );
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                [ 'encrypt', 'decrypt' ]
            );
        }

        async function encryptData ( data, password )
        {
            const salt = crypto.getRandomValues( new Uint8Array( 16 ) );
            const iv = crypto.getRandomValues( new Uint8Array( 12 ) );
            const key = await generateKey( password, salt );
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            const ciphertext = new Uint8Array( encrypted );

            // Concatenate salt + iv + ciphertext
            const combinedData = new Uint8Array( salt.length + iv.length + ciphertext.length );
            combinedData.set( salt, 0 );
            combinedData.set( iv, salt.length );
            combinedData.set( ciphertext, salt.length + iv.length );

            return combinedData;
        }

        async function decryptData ( encryptedData, password )
        {
            const salt = encryptedData.slice( 0, 16 );
            const iv = encryptedData.slice( 16, 28 );
            const ciphertext = encryptedData.slice( 28 );

            const key = await generateKey( password, salt );
            try
            {
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    ciphertext
                );
                return new Uint8Array( decrypted );
            } catch ( e )
            {
                throw new Error( 'Incorrect password or corrupted data.' );
            }
        }

        function updateMaxDataSize ( img )
        {
            const selectedChannels = getSelectedChannels();
            const bitDepth = getBitDepth();
            const numChannels = selectedChannels.length;

            const availableBits = img.width * img.height * numChannels * bitDepth;
            maxDataSize = Math.floor( availableBits / 8 );

            maxBytesSpan.textContent = maxDataSize;
            updateTotalDataSize();
        }

        function updateCapacityBar ( totalDataSize )
        {

            const capacityUsed = ( totalDataSize / maxDataSize ) * 100;

            capacityFill.style.width = `${ Math.min( capacityUsed, 100 ) }%`;

            if ( capacityUsed > 100 )
            {
                capacityFill.style.backgroundColor = '#f44336'; // Red when over capacity
            } else
            {
                capacityFill.style.backgroundColor = '#4caf50'; // Green when within capacity
            }
        }

        function updateTotalDataSize ()
        {
            const messageSize = parseInt( messageSizeSpan.textContent ) || 0;
            const fileSize = parseInt( fileSizeSpan.textContent ) || 0;
            let totalDataSize = messageSize + fileSize;
            const password = document.getElementById( 'passwordInput' ).value;
            if ( password )
            {
                totalDataSize += 44; // 16 bytes salt + 12 bytes iv + 16 bytes tag
            }
            totalDataSizeSpan.textContent = totalDataSize;

            if ( maxDataSize > 0 && totalDataSize > maxDataSize )
            {
                const overBy = totalDataSize - maxDataSize;
                showMessage( `Total data size exceeds the maximum capacity of the image by ${ overBy } bytes.`, true );
                document.getElementById( 'encodeButton' ).disabled = true;
                totalDataSizeLine.classList.add( 'over-limit' );
            } else
            {
                clearMessage();
                updateEncodeButtonState();
                totalDataSizeLine.classList.remove( 'over-limit' );
            }

            updateCapacityBar( totalDataSize );
        }

        function updateEncodeSettings ()
        {
            const img = uploadImageWriteInput.files[ 0 ];
            if ( img )
            {
                // Recalculate max data size
                const reader = new FileReader();
                reader.onload = () =>
                {
                    const image = new Image();
                    image.onload = () =>
                    {
                        updateMaxDataSize( image );
                    };
                    image.src = reader.result;
                };
                reader.readAsDataURL( img );
            }
            updateEncodeButtonState();
        }

        function renderDifferenceImage ( originalImageData, encodedImageData )
        {
            const width = originalImageData.width;
            const height = originalImageData.height;

            const diffImageData = differenceCtx.createImageData( width, height );
            const diffData = diffImageData.data;

            const originalData = originalImageData.data;
            const encodedData = encodedImageData.data;

            for ( let i = 0; i < originalData.length; i += 4 )
            {
                // Compute the absolute difference for each color channel
                const rDiff = Math.abs( originalData[ i ] - encodedData[ i ] );
                const gDiff = Math.abs( originalData[ i + 1 ] - encodedData[ i + 1 ] );
                const bDiff = Math.abs( originalData[ i + 2 ] - encodedData[ i + 2 ] );

                // Amplify the difference for visibility
                diffData[ i ] = Math.min( rDiff * amplificationFactor, 255 );
                diffData[ i + 1 ] = Math.min( gDiff * amplificationFactor, 255 );
                diffData[ i + 2 ] = Math.min( bDiff * amplificationFactor, 255 );
                diffData[ i + 3 ] = 255; // Set alpha channel to fully opaque
            }

            differenceCtx.putImageData( diffImageData, 0, 0 );
        }

        function toggleImagesSection ()
        {
            if ( imagesSection.classList.contains( 'show' ) )
            {
                imagesSection.classList.remove( 'show' );
                toggleImagesButton.textContent = 'Show Images';
            } else
            {
                imagesSection.classList.add( 'show' );
                toggleImagesButton.textContent = 'Hide Images';
            }
        }

        function showSpinner ()
        {
            spinner.style.display = 'block';
        }

        function hideSpinner ()
        {
            spinner.style.display = 'none';
        }

        function showMessage ( text, isError = true )
        {
            messageBox.className = isError ? 'error' : 'success';
            messageBox.textContent = text;
            messageBox.style.display = 'block';

            // Start fade-out after 4 seconds (display duration)
            setTimeout( () =>
            {
                messageBox.classList.add( 'fade-out' );
            }, 4000 );

            // Hide after 5 seconds (allowing 1 second for fade-out)
            setTimeout( () =>
            {
                messageBox.style.display = 'none';
                messageBox.classList.remove( 'fade-out' );
            }, 5000 );
        }

        function clearMessage ()
        {
            messageBox.textContent = '';
            messageBox.style.display = 'none';
            messageBox.classList.remove( 'fade-out' );
        }

        function isFillRandomDataEnabled ()
        {
            return fillRandomDataCheckbox.checked;
        }

        function getSelectedChannels ()
        {
            const channels = [];
            if ( channelRed.checked ) channels.push( 'R' );
            if ( channelGreen.checked ) channels.push( 'G' );
            if ( channelBlue.checked ) channels.push( 'B' );
            return channels;
        }

        function getBitDepth ()
        {
            const bitDepth = parseInt( bitDepthInput.value );
            return Math.min( Math.max( bitDepth, 1 ), 16 );
        }

        function updateEncodeButtonState ()
        {
            const imageUploaded = uploadImageWriteInput.files.length > 0;
            const messageProvided = messageInput.value.length > 0 || uploadedFileData;
            const messageSize = parseInt( messageSizeSpan.textContent ) || 0;
            const fileSize = parseInt( fileSizeSpan.textContent ) || 0;
            const totalDataSize = messageSize + fileSize;

            const canEncode = imageUploaded && messageProvided && ( totalDataSize <= maxDataSize );
            document.getElementById( 'encodeButton' ).disabled = !canEncode;
        }

        function updateDecodeButtonState ()
        {
            const imageUploaded = uploadImageReadInput.files.length > 0;
            decodeButton.disabled = !imageUploaded;
        }

        encodeButton.addEventListener( 'click', async () =>
        {
            clearMessage();
            showSpinner();
            try
            {
                const fileInput = uploadImageWriteInput;
                const message = messageInput.value;
                const password = document.getElementById( 'passwordInput' ).value;

                if ( !fileInput.files.length )
                {
                    showMessage( 'Please upload an image.' );
                    return;
                }

                if ( !message && !uploadedFileData )
                {
                    showMessage( 'Please enter a message or upload a file to encode.' );
                    return;
                }

                const file = fileInput.files[ 0 ];
                const reader = new FileReader();
                reader.onload = () =>
                {
                    const img = new Image();
                    img.onload = async () =>
                    {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage( img, 0, 0 );
                        const imageData = ctx.getImageData( 0, 0, img.width, img.height );
                        // Copy the original image data
                        originalImageData = new ImageData(
                            new Uint8ClampedArray( imageData.data ),
                            imageData.width,
                            imageData.height
                        );

                        await encodeData( imageData.data, message, uploadedFileData, password );
                        ctx.putImageData( imageData, 0, 0 );
                        encodedImageData = ctx.getImageData( 0, 0, img.width, img.height );

                        // Render the encoded image on encodedCanvas
                        encodedCanvas.width = img.width;
                        encodedCanvas.height = img.height;
                        encodedCtx.putImageData( encodedImageData, 0, 0 );

                        // Compute and render the difference image
                        renderDifferenceImage( originalImageData, encodedImageData );

                        const encodedImage = canvas.toDataURL( 'image/png' );
                        //const downloadLink = document.getElementById( 'downloadLink' );
                        downloadLink.style.display = 'inline';
                        downloadLink.href = encodedImage;
                        downloadLink.download = 'encoded-image.png';
                        downloadLink.textContent = 'Download Encoded Image';
                        showMessage( 'Encoding completed successfully!', false );
                        // Automatically show the images section after encoding
                        if ( !imagesSection.classList.contains( 'show' ) )
                        {
                            imagesSection.classList.add( 'show' );
                            toggleImagesButton.textContent = 'Hide Images';
                        }
                    };
                    img.src = reader.result;
                };
                reader.readAsDataURL( file );
            } catch ( error )
            {
                showMessage( 'An error occurred during encoding.' );
            } finally
            {
                hideSpinner();
            }
        } );

        decodeButton.addEventListener( 'click', async () =>
        {
            clearMessage();
            showSpinner();
            try
            {
                const password = document.getElementById( 'passwordInputDecode' ).value;

                if ( !uploadImageReadInput.files.length )
                {
                    showMessage( 'Please upload an image.' );
                    return;
                }
                const file = uploadImageReadInput.files[ 0 ];
                const reader = new FileReader();
                reader.onload = () =>
                {
                    const img = new Image();
                    img.onload = async () =>
                    {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage( img, 0, 0 );
                        const imageData = ctx.getImageData( 0, 0, img.width, img.height );
                        const result = await decodeData( imageData.data, password );

                        if ( !result ) return;

                        if ( result.text )
                        {
                            decodedMessage.style.display = 'block';
                            decodedMessage.querySelector( 'span' ).textContent = result.text;
                        } else
                        {
                            decodedMessage.style.display = 'none';
                        }

                        if ( result.file )
                        {
                            const blob = new Blob( [ result.file.content ], { type: result.file.mimeType } );
                            const url = URL.createObjectURL( blob );
                            downloadDecodedFile.style.display = 'inline';
                            downloadDecodedFile.href = url;
                            downloadDecodedFile.download = result.file.fileName;
                            downloadDecodedFile.textContent = `Download Decoded File (${ result.file.fileName })`;
                        } else
                        {
                            downloadDecodedFile.style.display = 'none';
                        }
                    };
                    img.src = reader.result;
                };
                reader.readAsDataURL( file );
            } catch ( error )
            {
                showMessage( 'An error occurred during decoding.' );
            } finally
            {
                hideSpinner();
            }
        } );

        document.getElementById( 'messageInput' ).addEventListener( 'input', () =>
        {
            const message = messageInput.value;
            const size = new Blob( [ message ] ).size; // Size in bytes
            messageSizeSpan.textContent = size;
            updateTotalDataSize();
            updateEncodeButtonState();
        } );

        document.getElementById( 'uploadFile' ).addEventListener( 'change', ( event ) =>
        {
            const file = event.target.files[ 0 ];
            if ( file )
            {
                const reader = new FileReader();
                reader.onload = () =>
                {
                    uploadedFileData = reader.result;
                    const size = file.size;
                    fileSizeSpan.textContent = size;
                    updateTotalDataSize();
                    updateEncodeButtonState();
                };
                reader.readAsArrayBuffer( file );
            } else
            {
                uploadedFileData = null;
                fileSizeSpan.textContent = 0;
                updateTotalDataSize();
                updateEncodeButtonState();
            }
        } );

        document.getElementById( 'uploadImageWrite' ).addEventListener( 'change', () =>
        {
            if ( !uploadImageWriteInput.files.length ) return;

            const file = uploadImageWriteInput.files[ 0 ];
            const reader = new FileReader();
            reader.onload = () =>
            {
                const img = new Image();
                img.onload = () =>
                {
                    //maxDataSize = Math.floor( ( img.width * img.height * 3 ) / 8 );
                    updateMaxDataSize( img )

                    // Display the original image
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    originalCtx.drawImage( img, 0, 0 );

                    // Clear the encoded and difference canvases
                    encodedCtx.clearRect( 0, 0, encodedCanvas.width, encodedCanvas.height );
                    differenceCtx.clearRect( 0, 0, differenceCanvas.width, differenceCanvas.height );

                    // Optionally, adjust canvas sizes
                    encodedCanvas.width = img.width;
                    encodedCanvas.height = img.height;
                    differenceCanvas.width = img.width;
                    differenceCanvas.height = img.height;

                    maxBytesSpan.textContent = maxDataSize;
                    updateTotalDataSize();
                };
                img.src = reader.result;
            };
            reader.readAsDataURL( file );
            updateEncodeButtonState();
        } );

        channelRed.addEventListener( 'change', () => updateEncodeSettings() );
        channelGreen.addEventListener( 'change', () => updateEncodeSettings() );
        channelBlue.addEventListener( 'change', () => updateEncodeSettings() );
        bitDepthInput.addEventListener( 'input', () => updateEncodeSettings() );
        uploadImageReadInput.addEventListener( 'change', updateDecodeButtonState );
        amplificationSlider.addEventListener( 'input', () =>
        {
            amplificationFactor = parseInt( amplificationSlider.value );
            amplificationValue.textContent = amplificationFactor;

            // Re-render the difference image
            if ( originalImageData && encodedImageData )
            {
                renderDifferenceImage( originalImageData, encodedImageData );
            }
        } );

        toggleImagesButton.addEventListener( 'click', toggleImagesSection );

        updateEncodeButtonState();
        updateDecodeButtonState();
    </script>
</body>
<!--
        MIT License

        Copyright (c) 2024 derbydefi

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
        -->

</html>
