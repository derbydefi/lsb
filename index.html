<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>LSB Steganography Tool</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            font-family: 'IBM Plex Mono', monospace;
            background: #121212;
            color: #d3d3d3;
            line-height: 1.6;
            background-size: 8px 8px;
            background-repeat: repeat;
        }

        h1 {
            font-size: 2rem;
            margin-top: 20px;
            color: #d3d3d3;
            text-align: center;
            text-shadow: 0px 1px 0px #000;
            border-bottom: 1px solid #d3d3d3;
            padding-bottom: 5px;
            width: 90%;
            max-width: 600px;
        }

        section {
            background-color: #1b1b1b;
            border: 1px solid #333;
            padding: 10px;
            border-radius: 4px;
            width: 90%;
            max-width: 600px;
            margin-bottom: 30px;
        }

        h2 {
            font-size: 1.2rem;
            color: #d3d3d3;
            margin-bottom: 15px;
            border-bottom: 1px dashed #555;
            padding-bottom: 5px;
        }

        label {
            font-size: 0.9rem;
            color: #a3a3a3;
        }

        input,
        textarea,
        button,
        a {
            width: 100%;
            margin: 10px 0;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #555;
            background: #2b2b2b;
            color: #d3d3d3;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
        }

        input:focus,
        textarea:focus {
            border-color: #999;
            outline: none;
        }

        button {
            background: #444;
            color: #d3d3d3;
            font-family: 'IBM Plex Mono', monospace;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #555;
        }

        button:disabled {
            background: #333;
            cursor: not-allowed;
        }

        a {
            text-align: center;
            text-decoration: none;
            background: #444;
            color: #d3d3d3;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            transition: background 0.2s;
        }

        a:hover {
            background: #555;
        }

        #spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1rem;
            color: #d3d3d3;
            display: none;
        }

        #messageBox {
            margin: 20px 0;
            text-align: center;
            padding: 5px;
            border-radius: 4px;
            background: #222;
            border: 1px solid #333;
            opacity: 1;
            transition: opacity 1s ease-in-out;
            display: none;
        }

        #decodedMessage {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid #555;
            background: #2b2b2b;
            color: #d3d3d3;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            box-sizing: border-box;
            padding: 8px;
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #messageBox.error {
            background: #331111;
            color: #ffaaaa;
        }

        #messageBox.success {
            background: #113311;
            color: #aaffaa;
        }

        #messageBox.fade-out {
            opacity: 0;
        }

        .size-info {
            width: 100%;
            margin: 10px 0;
            border-collapse: collapse;
        }

        .size-info td {
            padding: 5px;
            font-size: 0.9rem;
            color: #d3d3d3;
        }

        .size-info tr:nth-child(even) {
            background-color: #1e1e1e;
        }

        .size-info tr:nth-child(odd) {
            background-color: #2b2b2b;
        }

        .size-info td:first-child {
            text-align: left;
        }

        .size-info td:last-child {
            text-align: right;
        }

        .size-info tr.over-limit td {
            color: #ff5555;
            font-weight: bold;
        }

        .settings-group {
            margin-top: 20px;
        }

        .settings-group label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #d3d3d3;
            cursor: pointer;
        }

        .settings-group input[type="checkbox"] {
            margin-right: 5px;
            accent-color: #444;
            width: 16px;
            height: 16px;
        }

        #channelSelection {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        #channelSelection label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #d3d3d3;
            cursor: pointer;
        }

        #channelSelection input[type="checkbox"] {
            margin-right: 5px;
            accent-color: #444;
            width: 16px;
            height: 16px;
        }

        #bitDepth {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #555;
            background: #2b2b2b;
            color: #d3d3d3;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
        }

        #bitDepth:focus {
            border-color: #999;
            outline: none;
        }

        .capacity-bar {
            width: 100%;
            background-color: #2b2b2b;
            border: 1px solid #555;
            border-radius: 4px;
            margin-bottom: 10px;
            height: 20px;
            overflow: hidden;
        }

        .capacity-fill {
            height: 100%;
            background-color: #4caf50;
            width: 0%;
            transition: width 0.3s;
        }

        .image-display {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin-top: 10px;
        }

        .image-container {
            margin: 5px;
            text-align: center;
        }

        .image-container h3 {
            font-size: 1rem;
            color: #d3d3d3;
            margin-bottom: 5px;
        }

        .image-container canvas {
            border: 1px solid #555;
            max-width: 100%;
            height: auto;
        }

        .canvas-slider-container {
            width: 100%;
        }

        .canvas-container canvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        .canvas-slider-container canvas,
        .canvas-slider-container #amplificationSlider {
            width: 100%;
            box-sizing: border-box;
        }

        #imagesSection {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
        }

        #imagesSection.show {
            max-height: 2000px;
        }

        #toggleImagesButton {
            background: #444;
            color: #d3d3d3;
            font-family: 'IBM Plex Mono', monospace;
            cursor: pointer;
            transition: background 0.2s;
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #555;
            margin-top: 10px;
        }

        #toggleImagesButton:hover {
            background: #555;
        }

        .download-container {
            text-align: right;
        }

        .encryption-notice {
            font-size: 0.8rem;
            margin-top: 10px;
            color: #aaa;
        }

        .encryption-notice a {
            font-size: 0.8rem;
            color: #aaa;
            text-decoration: underline;
            margin-top: 5px;
            display: block;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5rem;
            }

            input,
            textarea,
            button,
            a {
                font-size: 0.8rem;
            }

            #channelSelection {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>

<body>
    <h1>â§‰ LSB Steganography Tool</h1>
    <div id="messageBox"></div>
    <section>
        <h2>Read And Decode Data From Encoded Image</h2>
        <label for="uploadImageRead">Upload Image</label>
        <input type="file" id="uploadImageRead" accept="image/*">
        <label for="passwordInputDecode">
            Password (optional):

        </label>
        <input type="password" id="passwordInputDecode" placeholder="Enter password for decryption">
        <div class="button-container">
            <button id="decodeButton" disabled>Decode Data</button>
        </div>
        <div class="download-container">
            <a id="downloadDecodedFile" style="display: none;">Download Decoded File</a>
        </div>
        <p id="decodedMessage">Decoded Message: <span></span></p>
    </section>
    <section>
        <h2>Write Image With Encoded Data</h2>
        <label for="uploadImageWrite">Source Image</label>
        <input type="file" id="uploadImageWrite" accept="image/*">

        <label for="passwordInput">
            Password (optional):

        </label>
        <input type="password" id="passwordInput" placeholder="Enter password for encryption or leave blank">


        <label for="uploadFile">Upload File (optional)</label>
        <input type="file" id="uploadFile" accept="*">
        <textarea id="messageInput" placeholder="Enter Message"></textarea>
        <table class="size-info">
            <tr>
                <td>Message Size:</td>
                <td><span id="messageSize">0</span> bytes</td>
            </tr>
        </table>
        <table class="size-info">
            <tr>
                <td>File Size:</td>
                <td><span id="fileSize">0</span> bytes</td>
            </tr>
        </table>
        <table class="size-info">
            <tr id="totalDataSizeLine">
                <td>Total Data Size:</td>
                <td><span id="totalDataSize">0</span> bytes</td>
            </tr>
        </table>
        <table class="size-info">
            <tr>
                <td>Max Data Size:</td>
                <td id="maxBytes"><span>0</span> bytes</td>
            </tr>
        </table>
        <div class="capacity-bar">
            <div class="capacity-fill" id="capacityFill"></div>
        </div>
        <div class="settings-group">
            <label>Encoding Color Channels:</label>
            <div id="channelSelection">
                <label><input type="checkbox" id="channelRed" checked> Red</label>
                <label><input type="checkbox" id="channelGreen"> Green</label>
                <label><input type="checkbox" id="channelBlue"> Blue</label>
            </div>
            <label for="bitDepth">Bit Depth Per Channel:</label>
            <input type="number" id="bitDepth" value="1" min="1" max="16">
            <label><input type="checkbox" id="fillRandomData"> Fill remaining space with random data</label>
        </div>
        <div class="button-container">
            <button id="encodeButton" disabled>Encode Data</button>
        </div>
        <div class="download-container">
            <a id="downloadLink" style="display: none;">Download Encoded Image</a>
        </div>
        <button id="toggleImagesButton">Show Images</button>
        <div id="imagesSection">
            <div class="image-display">
                <div class="image-container">
                    <h3>Original Image</h3>
                    <div class="canvas-container">
                        <canvas id="originalCanvas"></canvas>
                    </div>
                </div>
                <div class="image-container">
                    <h3>Difference</h3>
                    <div class="canvas-container">
                        <canvas id="differenceCanvas"></canvas>
                        <input type="range" id="amplificationSlider" min="1" max="100" value="16">
                    </div>
                    <label for="amplificationSlider">Amplification Factor: <span
                            id="amplificationValue">16</span></label>
                </div>
                <div class="image-container">
                    <h3>Encoded Image</h3>
                    <div class="canvas-container">
                        <canvas id="encodedCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="encryption-notice">
            <p>
                If a password is provided, data will be encrypted using AES-GCM.
                If running on a non-secure environment or encountering issues, try running locally.
            </p>
            <a href="#" id="downloadPageLink" download="index.html">
                Right-click this link and select "Save link as..." to download this page and run locally
            </a>
        </div>
    </section>
    <div id="spinner">Processing...</div>
    <canvas id="canvas" style="display: none;"></canvas>

    <script>
        /*
         * LSB Steganography Tool
         * Copyright (c) 2024 derbydefi
         * Released under the MIT License
         * See the full license text at the bottom of this file.
         */

        const canvas = document.getElementById( "canvas" );
        const ctx = canvas.getContext( "2d" );
        let maxDataSize = 0;
        let amplificationFactor = 16; // Default value
        let uploadedFileData = null;
        let originalImageData = null;
        let encodedImageData = null;

        const originalCanvas = document.getElementById( "originalCanvas" );
        const originalCtx = originalCanvas.getContext( "2d" );
        const encodedCanvas = document.getElementById( "encodedCanvas" );
        const encodedCtx = encodedCanvas.getContext( "2d" );
        const differenceCanvas = document.getElementById( "differenceCanvas" );
        const differenceCtx = differenceCanvas.getContext( "2d" );

        // UI Elements
        const toggleImagesButton = document.getElementById( "toggleImagesButton" );
        const imagesSection = document.getElementById( "imagesSection" );
        const spinner = document.getElementById( "spinner" );
        const messageBox = document.getElementById( "messageBox" );
        const decodeButton = document.getElementById( "decodeButton" );
        const encodeButton = document.getElementById( "encodeButton" );
        const downloadDecodedFile = document.getElementById( "downloadDecodedFile" );
        const downloadLink = document.getElementById( "downloadLink" );
        const amplificationSlider = document.getElementById( "amplificationSlider" );
        const amplificationValue = document.getElementById( "amplificationValue" );
        const fillRandomDataCheckbox = document.getElementById( "fillRandomData" );
        const channelRed = document.getElementById( "channelRed" );
        const channelGreen = document.getElementById( "channelGreen" );
        const channelBlue = document.getElementById( "channelBlue" );
        const bitDepthInput = document.getElementById( "bitDepth" );
        const messageInput = document.getElementById( "messageInput" );
        const uploadFileInput = document.getElementById( "uploadFile" );
        const uploadImageWriteInput = document.getElementById( "uploadImageWrite" );
        const uploadImageReadInput = document.getElementById( "uploadImageRead" );
        const decodedMessage = document.getElementById( "decodedMessage" );
        const messageSizeSpan = document.getElementById( "messageSize" );
        const fileSizeSpan = document.getElementById( "fileSize" );
        const totalDataSizeSpan = document.getElementById( "totalDataSize" );
        const maxBytesSpan = document.querySelector( "#maxBytes span" );
        const capacityFill = document.getElementById( "capacityFill" );
        const totalDataSizeLine = document.getElementById( "totalDataSizeLine" );
        const passwordInput = document.getElementById( "passwordInput" );
        const passwordInputDecode = document.getElementById( "passwordInputDecode" );

        function generateRandomBytes ( size )
        {
            const MAX_BYTES = 65536; // Maximum bytes per call
            const bytes = new Uint8Array( size );
            let generated = 0;

            while ( generated < size )
            {
                const chunkSize = Math.min( MAX_BYTES, size - generated );
                const chunk = new Uint8Array( chunkSize );
                window.crypto.getRandomValues( chunk );
                bytes.set( chunk, generated );
                generated += chunkSize;
            }

            return bytes;
        }

        function encodeText ( text )
        {
            return new TextEncoder().encode( text );
        }

        function decodeText ( data )
        {
            return new TextDecoder().decode( data );
        }

        async function encodeData ( data, message, fileData, password )
        {
            let totalDataBytes = new Uint8Array();
            let hasText = message.length > 0;
            let hasFile = fileData !== null;

            if ( !hasText && !hasFile )
            {
                showMessage( "No data to encode." );
                return;
            }

            // Prepare text data
            if ( hasText )
            {
                const messageEncoded = encodeText( message );
                const textLengthBuffer = new ArrayBuffer( 4 );
                new DataView( textLengthBuffer ).setUint32( 0, messageEncoded.length );
                const textBytes = new Uint8Array( [
                    ...new Uint8Array( textLengthBuffer ),
                    ...messageEncoded,
                ] );
                totalDataBytes = hasFile ? new Uint8Array( [ ...textBytes ] ) : textBytes;
            }

            // Prepare file data
            if ( hasFile )
            {
                const fileInput = uploadFileInput;
                const file = fileInput.files[ 0 ];
                const fileName = file.name;
                const mimeType = file.type;
                const fileNameBytes = encodeText( fileName );
                const mimeTypeBytes = encodeText( mimeType );

                const fileNameLengthBuffer = new ArrayBuffer( 4 );
                new DataView( fileNameLengthBuffer ).setUint32( 0, fileNameBytes.length );
                const mimeTypeLengthBuffer = new ArrayBuffer( 4 );
                new DataView( mimeTypeLengthBuffer ).setUint32( 0, mimeTypeBytes.length );

                const fileContentBytes = new Uint8Array( fileData );

                const fileBytes = new Uint8Array(
                    fileNameLengthBuffer.byteLength +
                    fileNameBytes.length +
                    mimeTypeLengthBuffer.byteLength +
                    mimeTypeBytes.length +
                    fileContentBytes.length
                );

                let offset = 0;
                fileBytes.set( new Uint8Array( fileNameLengthBuffer ), offset );
                offset += fileNameLengthBuffer.byteLength;
                fileBytes.set( fileNameBytes, offset );
                offset += fileNameBytes.length;
                fileBytes.set( new Uint8Array( mimeTypeLengthBuffer ), offset );
                offset += mimeTypeLengthBuffer.byteLength;
                fileBytes.set( mimeTypeBytes, offset );
                offset += mimeTypeBytes.length;
                fileBytes.set( fileContentBytes, offset );

                if ( hasText )
                {
                    const combinedLength = totalDataBytes.length + fileBytes.length;
                    const combinedBytes = new Uint8Array( combinedLength );
                    combinedBytes.set( totalDataBytes, 0 );
                    combinedBytes.set( fileBytes, totalDataBytes.length );
                    totalDataBytes = combinedBytes;
                } else
                {
                    totalDataBytes = fileBytes;
                }
            }

            const encryptionEnabled = password && password.trim().length > 0;

            // Only encrypt if a password is provided
            if ( encryptionEnabled )
            {
                try
                {
                    totalDataBytes = await encryptData( totalDataBytes, password );
                } catch ( error )
                {
                    showMessage( "Encryption failed. Try running locally or leave password blank.", true );
                    return;
                }
            }

            const selectedChannels = getSelectedChannels();
            const bitDepth = getBitDepth();

            let header = {
                hasText: hasText,
                hasFile: hasFile,
                encrypted: encryptionEnabled,
                dataLength: totalDataBytes.length,
                channels: selectedChannels,
                bitDepth: bitDepth,
            };

            let headerString = JSON.stringify( header );
            let headerBytes = encodeText( headerString );
            let headerLength = headerBytes.length;

            if ( headerLength > 255 )
            {
                showMessage( "Header is too large.", true );
                return;
            }

            // Encode header length
            let dataIndex = 0;
            for ( let bit = 7; bit >= 0; bit-- )
            {
                let bitValue = ( headerLength >> bit ) & 1;
                data[ dataIndex ] = ( data[ dataIndex ] & ~1 ) | bitValue;
                dataIndex += 4;
            }

            // Encode header
            for ( let i = 0; i < headerLength; i++ )
            {
                let byte = headerBytes[ i ];
                for ( let bit = 7; bit >= 0; bit-- )
                {
                    let bitValue = ( byte >> bit ) & 1;
                    data[ dataIndex ] = ( data[ dataIndex ] & ~1 ) | bitValue;
                    dataIndex += 4;
                }
            }

            const bitsPerPixel = selectedChannels.length * bitDepth;
            let bitPosIndex = 0;
            let channelBitPositions = [];
            for ( let channel of selectedChannels )
            {
                for ( let bit = 0; bit < bitDepth; bit++ )
                {
                    channelBitPositions.push( { channel, bit } );
                }
            }

            // Encode main data
            for ( let i = 0; i < totalDataBytes.length; i++ )
            {
                let byte = totalDataBytes[ i ];
                for ( let bit = 7; bit >= 0; bit-- )
                {
                    let bitValue = ( byte >> bit ) & 1;

                    let pixelOffset = Math.floor( bitPosIndex / bitsPerPixel );
                    let bitWithinPixel = bitPosIndex % bitsPerPixel;
                    let { channel, bit: channelBit } = channelBitPositions[ bitWithinPixel ];

                    let dataIdx = dataIndex + pixelOffset * 4;
                    let channelIndex = { R: 0, G: 1, B: 2 }[ channel ];
                    let baseIndex = dataIdx + channelIndex;

                    let bitMask = 1 << channelBit;
                    data[ baseIndex ] = ( data[ baseIndex ] & ~bitMask ) | ( bitValue << channelBit );

                    bitPosIndex++;
                }
            }

            // Fill with random data if enabled
            if ( isFillRandomDataEnabled() )
            {
                const totalAvailableBits = ( data.length / 4 - dataIndex / 4 ) * bitsPerPixel;
                const totalRequiredBits = totalDataBytes.length * 8;
                const remainingBits = totalAvailableBits - totalRequiredBits;
                const remainingBytes = Math.floor( remainingBits / 8 );

                if ( remainingBytes > 0 )
                {
                    const randomBytes = generateRandomBytes( remainingBytes );
                    for ( let i = 0; i < randomBytes.length; i++ )
                    {
                        let byte = randomBytes[ i ];
                        for ( let bit = 7; bit >= 0; bit-- )
                        {
                            let bitValue = ( byte >> bit ) & 1;

                            let pixelOffset = Math.floor( bitPosIndex / bitsPerPixel );
                            let bitWithinPixel = bitPosIndex % bitsPerPixel;
                            let { channel, bit: channelBit } = channelBitPositions[ bitWithinPixel ];

                            let dataIdx = dataIndex + pixelOffset * 4;
                            let channelIndex = { R: 0, G: 1, B: 2 }[ channel ];
                            let baseIndex = dataIdx + channelIndex;

                            let bitMask = 1 << channelBit;
                            data[ baseIndex ] =
                                ( data[ baseIndex ] & ~bitMask ) | ( bitValue << channelBit );

                            bitPosIndex++;
                        }
                    }
                }
            }
        }

        async function decodeData ( data, password )
        {
            let dataIndex = 0;

            // Read header length
            let headerLength = 0;
            for ( let bitIndex = 7; bitIndex >= 0; bitIndex-- )
            {
                let bit = data[ dataIndex ] & 1;
                headerLength |= bit << bitIndex;
                dataIndex += 4;
            }

            let headerBytes = new Uint8Array( headerLength );
            for ( let i = 0; i < headerLength; i++ )
            {
                let byte = 0;
                for ( let bitIndex = 7; bitIndex >= 0; bitIndex-- )
                {
                    let bit = data[ dataIndex ] & 1;
                    byte |= bit << bitIndex;
                    dataIndex += 4;
                }
                headerBytes[ i ] = byte;
            }
            const headerString = decodeText( headerBytes );
            const header = JSON.parse( headerString );

            const selectedChannels = header.channels;
            const bitDepth = header.bitDepth;
            const encryptionEnabled = header.encrypted;

            let channelBitPositions = [];
            for ( let channel of selectedChannels )
            {
                for ( let bit = 0; bit < bitDepth; bit++ )
                {
                    channelBitPositions.push( { channel, bit } );
                }
            }

            const bitsPerPixel = channelBitPositions.length;
            let bitPosIndex = 0;
            let dataBytes = new Uint8Array( header.dataLength );

            for ( let i = 0; i < header.dataLength; i++ )
            {
                let byte = 0;
                for ( let bitIndex = 7; bitIndex >= 0; bitIndex-- )
                {
                    let pixelOffset = Math.floor( bitPosIndex / bitsPerPixel );
                    let bitWithinPixel = bitPosIndex % bitsPerPixel;
                    let { channel, bit: channelBit } = channelBitPositions[ bitWithinPixel ];

                    let dataIdx = dataIndex + pixelOffset * 4;
                    let channelIndex = { R: 0, G: 1, B: 2 }[ channel ];
                    let baseIndex = dataIdx + channelIndex;

                    let bitMask = 1 << channelBit;
                    let bit = ( data[ baseIndex ] & bitMask ) >> channelBit;

                    byte |= bit << bitIndex;
                    bitPosIndex++;
                }
                dataBytes[ i ] = byte;
            }

            // Decrypt if enabled and password provided
            let binaryData;
            const decryptAttempt = encryptionEnabled && password && password.trim().length > 0;
            if ( decryptAttempt )
            {
                try
                {
                    binaryData = await decryptData( dataBytes, password );
                } catch ( e )
                {
                    showMessage(
                        "Failed to decrypt data. Check password or run locally without encryption.",
                        true
                    );
                    return null;
                }
            } else if ( encryptionEnabled && ( !password || password.trim() === "" ) )
            {
                showMessage( "Data is encrypted but no password provided.", true );
                return null;
            } else
            {
                binaryData = dataBytes;
            }

            let result = {};
            let offset = 0;

            if ( header.hasText )
            {
                const textLengthBytes = binaryData.slice( offset, offset + 4 );
                const textLength = new DataView( textLengthBytes.buffer ).getUint32( 0 );
                offset += 4;
                const textBytes = binaryData.slice( offset, offset + textLength );
                offset += textLength;
                const message = decodeText( textBytes );
                result.text = message;
            }

            if ( header.hasFile )
            {
                const fileNameLength = new DataView( binaryData.buffer, offset, 4 ).getUint32( 0 );
                offset += 4;
                const fileName = decodeText(
                    binaryData.slice( offset, offset + fileNameLength )
                );
                offset += fileNameLength;

                const mimeTypeLength = new DataView( binaryData.buffer, offset, 4 ).getUint32(
                    0
                );
                offset += 4;
                const mimeType = decodeText(
                    binaryData.slice( offset, offset + mimeTypeLength )
                );
                offset += mimeTypeLength;

                const fileContent = binaryData.slice( offset );
                result.file = {
                    fileName,
                    mimeType,
                    content: fileContent,
                };
            }

            return result;
        }

        async function generateKey ( password, salt )
        {
            const keyMaterial = await window.crypto.subtle.importKey(
                "raw",
                encodeText( password ),
                { name: "PBKDF2" },
                false,
                [ "deriveKey" ]
            );
            return window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                [ "encrypt", "decrypt" ]
            );
        }

        async function encryptData ( data, password )
        {
            const salt = window.crypto.getRandomValues( new Uint8Array( 16 ) );
            const iv = window.crypto.getRandomValues( new Uint8Array( 12 ) );
            const key = await generateKey( password, salt );
            const encrypted = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                data
            );
            const ciphertext = new Uint8Array( encrypted );

            const combinedData = new Uint8Array(
                salt.length + iv.length + ciphertext.length
            );
            combinedData.set( salt, 0 );
            combinedData.set( iv, salt.length );
            combinedData.set( ciphertext, salt.length + iv.length );
            return combinedData;
        }

        async function decryptData ( encryptedData, password )
        {
            const salt = encryptedData.slice( 0, 16 );
            const iv = encryptedData.slice( 16, 28 );
            const ciphertext = encryptedData.slice( 28 );

            const key = await generateKey( password, salt );
            try
            {
                const decrypted = await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    ciphertext
                );
                return new Uint8Array( decrypted );
            } catch ( e )
            {
                throw new Error( "Incorrect password or corrupted data." );
            }
        }

        function updateMaxDataSize ( img )
        {
            const selectedChannels = getSelectedChannels();
            const bitDepth = getBitDepth();
            const numChannels = selectedChannels.length;
            const availableBits = img.width * img.height * numChannels * bitDepth;
            maxDataSize = Math.floor( availableBits / 8 );

            maxBytesSpan.textContent = maxDataSize;
            updateTotalDataSize();
        }

        function updateCapacityBar ( totalDataSize )
        {
            const capacityUsed = ( totalDataSize / maxDataSize ) * 100;

            capacityFill.style.width = `${ Math.min( capacityUsed, 100 ) }%`;

            if ( capacityUsed > 100 )
            {
                capacityFill.style.backgroundColor = "#f44336";
            } else
            {
                capacityFill.style.backgroundColor = "#4caf50";
            }
        }

        function updateTotalDataSize ()
        {
            const messageSize = parseInt( messageSizeSpan.textContent ) || 0;
            const fileSize = parseInt( fileSizeSpan.textContent ) || 0;
            let totalDataSize = messageSize + fileSize;

            // Add overhead for encryption if password is present
            const password = passwordInput.value;
            if ( password && password.trim().length > 0 )
            {
                // Encryption adds salt + iv + tag overhead. 
                // In AES-GCM, tag is included automatically in the ciphertext (16 bytes). 
                // Salt(16)+IV(12)+tag(16) ~ 44 bytes overhead total.
                totalDataSize += 44;
            }

            totalDataSizeSpan.textContent = totalDataSize;

            if ( maxDataSize > 0 && totalDataSize > maxDataSize )
            {
                const overBy = totalDataSize - maxDataSize;
                showMessage(
                    `Total data size exceeds the maximum capacity of the image by ${ overBy } bytes.`,
                    true
                );
                document.getElementById( "encodeButton" ).disabled = true;
                totalDataSizeLine.classList.add( "over-limit" );
            } else
            {
                clearMessage();
                updateEncodeButtonState();
                totalDataSizeLine.classList.remove( "over-limit" );
            }

            updateCapacityBar( totalDataSize );
        }

        function updateEncodeSettings ()
        {
            const img = uploadImageWriteInput.files[ 0 ];
            if ( img )
            {
                const reader = new FileReader();
                reader.onload = () =>
                {
                    const image = new Image();
                    image.onload = () =>
                    {
                        updateMaxDataSize( image );
                    };
                    image.src = reader.result;
                };
                reader.readAsDataURL( img );
            }
            updateEncodeButtonState();
        }

        function renderDifferenceImage ( originalImageData, encodedImageData )
        {
            const width = originalImageData.width;
            const height = originalImageData.height;

            const diffImageData = differenceCtx.createImageData( width, height );
            const diffData = diffImageData.data;

            const originalData = originalImageData.data;
            const encodedData = encodedImageData.data;

            for ( let i = 0; i < originalData.length; i += 4 )
            {
                const rDiff = Math.abs( originalData[ i ] - encodedData[ i ] );
                const gDiff = Math.abs( originalData[ i + 1 ] - encodedData[ i + 1 ] );
                const bDiff = Math.abs( originalData[ i + 2 ] - encodedData[ i + 2 ] );

                diffData[ i ] = Math.min( rDiff * amplificationFactor, 255 );
                diffData[ i + 1 ] = Math.min( gDiff * amplificationFactor, 255 );
                diffData[ i + 2 ] = Math.min( bDiff * amplificationFactor, 255 );
                diffData[ i + 3 ] = 255;
            }

            differenceCtx.putImageData( diffImageData, 0, 0 );
        }

        function toggleImagesSection ()
        {
            if ( imagesSection.classList.contains( "show" ) )
            {
                imagesSection.classList.remove( "show" );
                toggleImagesButton.textContent = "Show Images";
            } else
            {
                imagesSection.classList.add( "show" );
                toggleImagesButton.textContent = "Hide Images";
            }
        }

        function showSpinner ()
        {
            spinner.style.display = "block";
        }

        function hideSpinner ()
        {
            spinner.style.display = "none";
        }

        function showMessage ( text, isError = true )
        {
            messageBox.className = isError ? "error" : "success";
            messageBox.textContent = text;
            messageBox.style.display = "block";

            setTimeout( () =>
            {
                messageBox.classList.add( "fade-out" );
            }, 4000 );

            setTimeout( () =>
            {
                messageBox.style.display = "none";
                messageBox.classList.remove( "fade-out" );
            }, 5000 );
        }

        function clearMessage ()
        {
            messageBox.textContent = "";
            messageBox.style.display = "none";
            messageBox.classList.remove( "fade-out" );
        }

        function isFillRandomDataEnabled ()
        {
            return fillRandomDataCheckbox.checked;
        }

        function getSelectedChannels ()
        {
            const channels = [];
            if ( channelRed.checked ) channels.push( "R" );
            if ( channelGreen.checked ) channels.push( "G" );
            if ( channelBlue.checked ) channels.push( "B" );
            return channels;
        }

        function getBitDepth ()
        {
            const bitDepth = parseInt( bitDepthInput.value );
            return Math.min( Math.max( bitDepth, 1 ), 16 );
        }

        function updateEncodeButtonState ()
        {
            const imageUploaded = uploadImageWriteInput.files.length > 0;
            const messageProvided = messageInput.value.length > 0 || uploadedFileData;
            const messageSize = parseInt( messageSizeSpan.textContent ) || 0;
            const fileSize = parseInt( fileSizeSpan.textContent ) || 0;
            let totalDataSize = messageSize + fileSize;

            const password = passwordInput.value;
            if ( password && password.trim().length > 0 )
            {
                totalDataSize += 44;
            }

            const canEncode =
                imageUploaded && messageProvided && totalDataSize <= maxDataSize;
            document.getElementById( "encodeButton" ).disabled = !canEncode;
        }

        function updateDecodeButtonState ()
        {
            const imageUploaded = uploadImageReadInput.files.length > 0;
            decodeButton.disabled = !imageUploaded;
        }

        encodeButton.addEventListener( "click", async () =>
        {
            clearMessage();
            showSpinner();
            try
            {
                const fileInput = uploadImageWriteInput;
                const message = messageInput.value;
                const password = passwordInput.value;

                if ( !fileInput.files.length )
                {
                    showMessage( "Please upload an image." );
                    return;
                }

                if ( !message && !uploadedFileData )
                {
                    showMessage( "Please enter a message or upload a file to encode." );
                    return;
                }

                const file = fileInput.files[ 0 ];
                const reader = new FileReader();
                reader.onload = () =>
                {
                    const img = new Image();
                    img.onload = async () =>
                    {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage( img, 0, 0 );
                        const imageData = ctx.getImageData( 0, 0, img.width, img.height );
                        originalImageData = new ImageData(
                            new Uint8ClampedArray( imageData.data ),
                            imageData.width,
                            imageData.height
                        );

                        await encodeData( imageData.data, message, uploadedFileData, password );
                        ctx.putImageData( imageData, 0, 0 );
                        encodedImageData = ctx.getImageData( 0, 0, img.width, img.height );

                        encodedCanvas.width = img.width;
                        encodedCanvas.height = img.height;
                        encodedCtx.putImageData( encodedImageData, 0, 0 );

                        renderDifferenceImage( originalImageData, encodedImageData );

                        canvas.toBlob( ( blob ) =>
                        {
                            const url = URL.createObjectURL( blob );
                            downloadLink.style.display = "inline";
                            downloadLink.href = url;
                            downloadLink.download = "encoded-image.png";
                            downloadLink.textContent = "Download Encoded Image";
                        }, "image/png" );

                        showMessage( "Encoding completed successfully!", false );
                        if ( !imagesSection.classList.contains( "show" ) )
                        {
                            imagesSection.classList.add( "show" );
                            toggleImagesButton.textContent = "Hide Images";
                        }
                    };
                    img.src = reader.result;
                };
                reader.readAsDataURL( file );
            } catch ( error )
            {
                showMessage( "An error occurred during encoding." );
            } finally
            {
                hideSpinner();
            }
        } );

        decodeButton.addEventListener( "click", async () =>
        {
            clearMessage();
            showSpinner();
            try
            {
                const password = passwordInputDecode.value;

                if ( !uploadImageReadInput.files.length )
                {
                    showMessage( "Please upload an image." );
                    return;
                }
                const file = uploadImageReadInput.files[ 0 ];
                const reader = new FileReader();
                reader.onload = () =>
                {
                    const img = new Image();
                    img.onload = async () =>
                    {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage( img, 0, 0 );
                        const imageData = ctx.getImageData( 0, 0, img.width, img.height );
                        const result = await decodeData( imageData.data, password );

                        if ( !result ) return;

                        if ( result.text )
                        {
                            decodedMessage.textContent = "Decoded Message:\n" + result.text;
                        } else
                        {
                            decodedMessage.textContent = "Decoded Message:";
                        }

                        if ( result.file )
                        {
                            const blob = new Blob( [ result.file.content ], {
                                type: result.file.mimeType,
                            } );
                            const url = URL.createObjectURL( blob );
                            downloadDecodedFile.style.display = "inline";
                            downloadDecodedFile.href = url;
                            downloadDecodedFile.download = result.file.fileName;
                            downloadDecodedFile.textContent = `Download Decoded File (${ result.file.fileName })`;
                        } else
                        {
                            downloadDecodedFile.style.display = "none";
                        }
                    };
                    img.src = reader.result;
                };
                reader.readAsDataURL( file );
            } catch ( error )
            {
                showMessage( "An error occurred during decoding." );
            } finally
            {
                hideSpinner();
            }
        } );

        document.getElementById( "messageInput" ).addEventListener( "input", () =>
        {
            const message = messageInput.value;
            const size = new Blob( [ message ] ).size;
            messageSizeSpan.textContent = size;
            updateTotalDataSize();
            updateEncodeButtonState();
        } );

        document.getElementById( "uploadFile" ).addEventListener( "change", ( event ) =>
        {
            const file = event.target.files[ 0 ];
            if ( file )
            {
                const reader = new FileReader();
                reader.onload = () =>
                {
                    uploadedFileData = reader.result;
                    const size = file.size;
                    fileSizeSpan.textContent = size;
                    updateTotalDataSize();
                    updateEncodeButtonState();
                };
                reader.readAsArrayBuffer( file );
            } else
            {
                uploadedFileData = null;
                fileSizeSpan.textContent = 0;
                updateTotalDataSize();
                updateEncodeButtonState();
            }
        } );

        document.getElementById( "uploadImageWrite" ).addEventListener( "change", () =>
        {
            if ( !uploadImageWriteInput.files.length ) return;

            const file = uploadImageWriteInput.files[ 0 ];
            const reader = new FileReader();
            reader.onload = () =>
            {
                const img = new Image();
                img.onload = () =>
                {
                    updateMaxDataSize( img );
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    originalCtx.drawImage( img, 0, 0 );

                    encodedCtx.clearRect( 0, 0, encodedCanvas.width, encodedCanvas.height );
                    differenceCtx.clearRect(
                        0,
                        0,
                        differenceCanvas.width,
                        differenceCanvas.height
                    );

                    encodedCanvas.width = img.width;
                    encodedCanvas.height = img.height;
                    differenceCanvas.width = img.width;
                    differenceCanvas.height = img.height;

                    maxBytesSpan.textContent = maxDataSize;
                    updateTotalDataSize();
                };
                img.src = reader.result;
            };
            reader.readAsDataURL( file );
            updateEncodeButtonState();
        } );

        channelRed.addEventListener( "change", () => updateEncodeSettings() );
        channelGreen.addEventListener( "change", () => updateEncodeSettings() );
        channelBlue.addEventListener( "change", () => updateEncodeSettings() );
        bitDepthInput.addEventListener( "input", () => updateEncodeSettings() );
        uploadImageReadInput.addEventListener( "change", updateDecodeButtonState );

        amplificationSlider.addEventListener( "input", () =>
        {
            amplificationFactor = parseInt( amplificationSlider.value );
            amplificationValue.textContent = amplificationFactor;

            if ( originalImageData && encodedImageData )
            {
                renderDifferenceImage( originalImageData, encodedImageData );
            }
        } );

        passwordInput.addEventListener( "input", () =>
        {
            updateTotalDataSize();
            updateEncodeButtonState();
        } );

        toggleImagesButton.addEventListener( "click", toggleImagesSection );
        updateEncodeButtonState();
        updateDecodeButtonState();
    </script>
    <!--
        MIT License

        Copyright (c) 2024 derbydefi

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
    -->
</body>

</html>
